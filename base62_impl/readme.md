## base62编解码方案

- 简介：顾名思义，它使用62个可打印字符（A-Z，a-z，0-9）来编码二进制(8bit数据)

- 映射规则
  - 十进制的0-9 =》62进制 0-9 
  - 十进制的10-35 =》62进制 a-z 
  - 十进制的36-61 =》62进制 A-Z

- 原理 与base64原理类似，base62即将任意8bit字节转换为用5bit（00111101）对应62个字符来表示
    - 第一步：将待转换字节流 按照每5Byte一组，一组就是40bit
    - 第二步：将40b每5b一组，共8组
    - 第三步：按 11111 => 0011 1101的形式填充0位（分别是头部2个0，最后一位前1个0）以使每组达到8bit长度，即变成8组8bit，共40bit变成了64bit
    - 第四步：根据base62映射表 将新的字节流转换为可打印字符串

### 空间浪费

base62映射表中的字符原本用5bit就可以表示，现在往里填充3个0bit，变成8bit，会有一定浪费。因此，base62编码之后的文本，比原文占用空间多大约60%
>base64是一组6bit，每组填充2bit，编码结果空间膨胀约30%

### 为什么5字节一组？

因为5bit和8bit（1B）的最小公倍数是40，40b就是5B；（重点：将原始字节流划分为 一份为5bit的 多个bit组，再通过补0填充为8bit）

### 字节长度不足5Byte的情况

比如原始字节流：00000001 (1B)，同样5bit一组划分，即 00000（1组） | 001（2组），第2组不足5bit在低位补0，得到 00100，
这里只有两组，再次对它们补0达到8bit，注意这时的补0形式是按上面第三步的方式进行，所以得到
0000 0000(1组) | 0000 1000(2组)
我们发现这里不足上面说的5组，没关系，在解码的时候判断字节长度就好了。
> 注意：base64的标准规范中，若分组不够时，会在尾部附加`=`,但其实可以不加，这里的base62编解码实现中就没有附加其他字符的逻辑

### 适用场景 
因为base64使用的字符包含'+/'，这两个字符在URL中属于专用字符需要转义后使用（转换为%xx的形式）较为麻烦，还有其他场景（如安全领域）、 也是同样的原因；这些场景使用base62显然更合适且简单
